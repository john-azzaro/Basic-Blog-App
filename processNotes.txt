Basic Blog App Process notes
============================




Objective
=========
    In this study, we'll make a basic blog application with CRUD operations (Create, Read, Update, and Delete) 
    functionality and implement mongoose so that we can store our information to a MongoDB database. I'm going
    to go step-by-step through the process as both a general guide for others and to document the process for
    myself in an effort to visualize and improve workflow.




Process Workflow Summary
========================

    Phase 1: Project Setup.
    Phase 2: Create (and Test) your server.
    Phase 3: Setup your database and server connection.
    Phase 4: Add initial middleware.
    Phase 5: Create a mongoose schema and model (and including virtuals and instance methods if needed).




Phase 1: Project Setup
=========================================================================================
-- This phase is comprised of basic setup, installation of dependencies, development 
   environment setup, and essential files like server.js, .gitignore, and .env.
=========================================================================================

    // Project Setup:                           
        1. Basic-Blog-App                                      -- Create a folder to store you application.
        2. npm init                                            -- Create a package.json file to start the project off (you can use npm inti -y to skip the questions).

    // Install express:
        3. npm install express                                 -- Install express (note: you can also type "npm i" to install).

    // Add .gitignore file for node_modules:        
        4. .gitignore > node_modules                           -- Add .gitignore file to ignore node_modules folder that was just added when you installed express.

    // Install application dependencies:
        5. npm install <dependencies>                          -- Install any other dependencies (if you need to at the outset of the project like mongoose).
        6. npm install --save-dev dotenv nodemon               -- Install development enviroment.

    // Create custom "devStart" script in package.json:     
        7. "devStart": "nodemon server.js"                     -- Running this command makes starting your server a little more streamlined.
        
    // Create initial application files:       
        8.1.   server.js                                       -- Creates a .js file for server code.
         
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Notes: 
            * Dont breeze through the npm init stage, take the time to setup the project correctly (i.e. server.js instead of index.js, etc.)
            * Submit everything AFTER you create the .gitignore file and add node_modules.
            * Install a developer enviroment as good practice, it makes things a lot easier in development even if you end up not using it.    
            * You can have multiple custom scripts. 
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   




Phase 2: Create (and Test) your server:
=============================================================================================================
-- This phase creates the basic express server and suggested testing stategy to ensure everything is working.
=============================================================================================================

    2.1:  Import express and instantiate the express application:
        ---------------------------------------------------------
            const express = require('express');
            const app = express();
        ---------------------------------------------------------


    2.2: Create a (temporary) basic server to test the connection:

        ----------------------------------------------------------                     ----------------------------------------------------------
            app.listen(3000, function() {                                                 let server; 
                console.log('Your app is listening on port 3000');         or...          server = app.listen(3000, function() {   
            });                                                                               console.log(`Listening on port 3000...`);   
        ----------------------------------------------------------                        });
                                                                                       ----------------------------------------------------------

    2.3: Test your connection
        * In gitbash, you will can run the server by running the custom script "devStart" with "npm run devStart".
        * If successful, you will see something like this:

            -----------------------------------------------------------------------
                $ npm run devStart

                > basic-blog-app@1.0.0 devStart C:\Users\Admin\Basic-Blog-App
                > nodemon server.js

                [nodemon] 1.19.4
                [nodemon] to restart at any time, enter `rs`
                [nodemon] watching dir(s): *.*
                [nodemon] watching extensions: js,mjs,json
                [nodemon] starting `node server.js`
                Your app is listening on port 3000
            -----------------------------------------------------------------------

        * And when you go to "localhost:3000", you should see "Cannot GET /", which means that the server is working,
          but no routes are present yet! 


        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Notes:
            * It might seem like extra work to create a basic app.listen function that you will need to heavily modify, if not entirely remove because
              of the intricacies of creating a mongoose server because it might seem redundant, but experience has shown that you always want to double
              check your work to make sure you have a good point to reference back to where everything was functioning the way it is supposed to.
            * IF you want to get in the habit of creating a server and account for EVENTUAL test integration, creating the server the second way
              in step 2.2 is preferable. When the time comes, you would simply need to replace the port number (i.e. 3000) and the message when you
              integrate this into the runServer function.         
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





Phase 3: Setup your database and server connection:
=======================================================================================================
-- This phase is all about setting up mongoose, a framework that provides a modeling enviroment for
   data, enforces structure, and manages relationships between data, providing schema validation, etc.
=======================================================================================================

    3.1: Import mongoose:
        * This will make mongoose available in our application code.
        ---------------------------------------------------------
            const mongoose = require('mongoose');
        ---------------------------------------------------------


    3.2: Configure mongoose to use ES6 promises:
        * Makes sure the application make use of promises since we'll be using promises in the 
          runServer and closeServer functions.
        ----------------------------------------------------------
            mongoose.Promise = global.Promise;
        ----------------------------------------------------------


    3:3. Create a config.js file:
        * The config.js file is where you can control the constants for the entire app, 
          such as database URL, PORT, etc.
        ---------------------------
            config.js
        ---------------------------


    3.4: In config.js, add the constants you want to connect to:
        * In the case of this app, we want a PORT and our database URL.
        --------------------------------------------------------------------------------------
            exports.DATABASE_URL = process.env.DATABASE_URL || 'mongodb://localhost/blog-app'; 
            exports.PORT = process.env.PORT || 8080; 
        --------------------------------------------------------------------------------------   


    3.5: Import values from config.js file into your server.js file: 
        * Basically, import everything from the config.js file into your server.js file.
        ---------------------------------------------------------------------------------------
            const { DATABASE_URL, PORT } = require('./config');
        ---------------------------------------------------------------------------------------


    3.6: Add a "server" variable:
        * By declaring "server" as a variable outside runServer because closeServer needs access to the
          server object, so by declaring server outside
        -----------------------------------
            let server;
        -----------------------------------


    3.7: Create a "runServer" function to connect to database and run HTTP server:
        * The runServer function connects to the MongoDB database and runs the server in unison. The 
          function does this in a specific order:
                1. Mongoose connects to our database using the URL's we provided in the config.js file.
                2. Listen for connections on the ports we specified (i.e. 8080 OR other specified env variable port).
                3. If successful, call a callback function if that connection worked. If unsuccessful, return error.
        ----------------------------------------------------------------------------------------------------------------
            
            let server;                                                                                                   // server declared OUTSIDE Run and Close.
        
            function runServer(databaseUrl, port=PORT) {                                                                  // To Run server: 
                return new Promise((resolve, reject) => {                                                                 // return Promise in which...
                    mongoose.connect(databaseUrl, { useNewUrlParser: true,  useUnifiedTopology: true }, err => {          // Mongoose connects to database:
                        if (err) {                                                                                        // If there is an error... 
                            return reject(err);                                                                           // ... return reject.
                        }       

                        server = app.listen(port, () => {                                                                 // Listen for connection to configured port.  
                            console.log(`Listening on port ${port}...`);                                                  // ... and log connection in terminal.
                            resolve();                                                                                    // and then the promise is resolved!
                        })
                        .on('error', err => {                                                                             // But if there is an error...
                            mongoose.disconnect();                                                                        // ... disconnect from mongoose...
                            reject(err);                                                                                  // and reject (passing in an error object).
                        });
                    });
                });
            }       

        -----------------------------------------------------------------------------------------------------------------  
        

    3.8: Create a "closeServer" function to close the server:
        * Although this seems unnecessary, including closeServer (and by extension the more complicated server connection 
          process outlined abovehis is going to come in handy when you to integration tests.
        ----------------------------------------------------------------------------------------------------------------
            
            function closeServer() {                                                                                       // To close server:
                return mongoose.disconnect().then(() => {                                                                  // disconnect and then...
                    return new Promise((resolve, reject) => {                                                              // return a promise which...
                        console.log("Closing server");                                                                     // ... will log "closing server"...
                        server.close(err => {                                                                              // and close the server...
                    if (err) {                                                                                             // and if there is an error, reject...
                    return reject(err);                                  
                    }
                    resolve();                                                                                             // else resolve.
                });
                });
            });
            }

        ----------------------------------------------------------------------------------------------------------------


    3.9: If server.js is called directly, run this block
        -----------------------------------------------------------------------------------
            if (require.main === module) {                                       
                runServer(DATABASE_URL).catch(err => console.error(err));
            }
        -----------------------------------------------------------------------------------

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Notes:
            * From what I can tell, configuring mongoose to use ES6 promises is more for legacy reasons and isnt needed in Mongoose 5+. However, it 
              seems like it is best to add this in just in case as a best practice.   
            * When you connect to mongoose, you need to pass in  "useNewUrlParser: true" and "useUnifiedTopology: true" to mongoose.connect to resolve
              deprecation issues.   
            * Special note on config.js files (vs. .env files): While both are used in development, config allows nested data while .env allows for
              a cleaner data structure. 
            * Another note on config.js (or .env) files: NORMALLY, you DO NOT want to commit these files to source control since they contain sensitive 
              information. I've included them in this project so you can follow along, but you would want to add your config/env file to your .gitignore
              at the outset.
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





Phase 4: Add initial middleware:
==================================================================================================
-- In this phase, you want to setup all the middleware that will be installed in your processing
   pipeline and stack. 
==================================================================================================

    4.1: Install initial built-in middleware:
        4.1.A: Setup server to accept json:
            * One of the most important initial middlewares to use is a built-in middleware called 
            express.json. This middleware allows the server to accept incoming requestsas a JSON body 
            rather than a GET, POST, element
                ---------------------------------------------------------
                    app.use(express.json());
                ---------------------------------------------------------

    4.2: Install initial third-party middleware:
        4.2.A: Setup morgan middleware.
            * After installing morgan in npm (npm install morgan), load the middleware in your server.js
              file and return the middleware.
                ----------------------------------------------------------
                const morgan = require('morgan');

                app.use(morgan('common'))
                ----------------------------------------------------------

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Notes: 
            * Middleware is code that runs after the server gets a request but BEFORE that request is sent to 
              your application routes. There can be many middlewares in your stack, running one after the other
              including built-in, third-party, and custom middleware.
            * To install a middleware function, you can use app.use(), which installs the middleware 
              function in the processing pipeline. When app.use() is called, the middleware will run
              for ALL requests to the application, even to non-existent endpoints.
            * For built-in middleware, you simply use "app.use()" and add in express.X where X is the built-in middleware, 
              including (but not limited to): app.use(express.static('public')) which serves static content from a single
              folder called "public" and houses html, js, css, etc.
            * For third-party middleware, you would need to install it using npm (i.e. npm morgan), load that middleware
              in your server.js file (i.e. const morgan = require('morgan')), and then return that middleware (i.e.
              app.use(morgan('tiny')); ).
            * For custom middleware, you would need to write a custom middleware function and then return that middleware:
                    function logErrors(err, req, res, next) {
                        console.log(err);                                              
                        return res.status(500).json({error: 'Something went wrong'})    
                    }
                    app.use(logErrors);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////






Phase 5: Create a mongoose schema and model (and including virtuals and instance methods if needed).
==============================================================================================================
-- A schema is used to define the shape of the documents in your collection. Once you have your schema,  you 
   need a mongoose model. A mongoose model wraps around the schema so that if can interface to the database 
   for creating, querying, updating, deleting, etc.  
-- To create a model, you need to first reference mongoose, define the schema, and export the model.
-- Besides schemas, you can include virtuals (manipulates properties in the schema object) and instance 
   methods (performs a specific action on a specific instance of a model).   
==============================================================================================================

    5.1: Create a models.js file:
        -----------------------------------
            models.js
        -----------------------------------

    5.2: Reference Mongoose:
        -----------------------------------------------------
            const mongoose = require('mongoose');            // load mongoose 
        -----------------------------------------------------

    5.3: Configure models.js to use ES6 promises:
        -----------------------------------------------------
            const mongoose = require('mongoose');
            mongoose.Promise = global.Promise;               // for ES6 promises
        -----------------------------------------------------

    5.4: Define Schema:
        * Every time you call the "blogPostSchema" schema, you will create a new instance of this class.
        -----------------------------------------------------
            const mongoose = require('mongoose');
            mongoose.Promise = global.Promise; 

            const blogPostSchema = mongoose.Schema({         // blogPostSchema defined.  
               // properties go here. 
            });
        -----------------------------------------------------

    5.5: Add properties inside your schema:
        * Each blog post will have the specified properties you have in your schema.
        * Again, what we are doing here is defining the shape of the documents you will save to your database.
        -------------------------------------------------------
            const mongoose = require('mongoose');
            mongoose.Promise = global.Promise;

            const blogPostSchema = mongoose.Schema({
                author: {                                    // author property with first and last name
                    firstName: String,
                    lastName: String
                },
                title: {                                     // title of the blog post
                    type: String, 
                    required: true
                }, 
                content: {                                   // content of the blog
                    type: String
                },
                created: {                                   // date create (default is the current data (Date.now)).
                    type: Date, 
                    default: Date.now
                }
            });
        --------------------------------------------------------

    5.6: Create a model for your schema(e.g. blogPostSchema)
        * In this case, we only have one schema, blogPostSchema, so we only need to create one model. 
          However, you would want to create more models for different schemas if needed.
        ----------------------------------------------------------------
            const mongoose = require('mongoose');
            mongoose.Promise = global.Promise;

            const blogPostSchema = mongoose.Schema({
                author: { 
                    firstName: String,
                    lastName: String
                },
                title: { 
                    type: String, 
                    required: true
                }, 
                content: {
                    type: String
                },
                created: {
                    type: Date, 
                    default: Date.now
                }
            });

            const BlogPost = mongoose.model('BlogPost', blogPostSchema);     // model for blogPostSchema
        ----------------------------------------------------------------

    5.7: Export the model for use in server.js.
        * You want to export all the models you want in a destuctured object.
        -----------------------------------------------------------------
            const mongoose = require('mongoose');
            mongoose.Promise = global.Promise;

            const blogPostSchema = mongoose.Schema({
                author: { 
                    firstName: String,
                    lastName: String
                },
                title: { 
                    type: String, 
                    required: true
                }, 
                content: {
                    type: String
                },
                created: {
                    type: Date, 
                    default: Date.now
                }
            });

            const BlogPost = mongoose.model('BlogPost', blogPostSchema);     

            module.exports = {BlogPost};                                     // export the BlogPost model created above.
        ----------------------------------------------------------------
        
    5.9: Create virtuals (if needed):


    5.10: Create an instance method:
        * An instance method is much like a security step where it allows you to select only certain properties from your schema.
        * For example, suppose your document has sensitive information like email and passwords that you do NOT want anyone else
          to see. An instance method would let you trim those sensitive peices out of the public view.
        * To do this, simply call the schema and chain ".method" which will create a custom method. Then, 
        -------------------------------------------------------------------
            
        -------------------------------------------------------------------






    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Notes:
        * 

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




